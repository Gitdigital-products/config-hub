Create this Rust module in your Config Hub project:

```rust
// src/rotation/mod.rs

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, SystemTime};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use tokio_cron_scheduler::{Job, JobScheduler};
use sqlx::{PgPool, Row};
use tracing::{info, warn, error};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SecretMetadata {
    pub id: String,
    pub key: String,
    pub secret_type: SecretType,
    pub rotation_interval: Duration,
    pub last_rotated_at: Option<DateTime<Utc>>,
    pub next_rotation_at: DateTime<Utc>,
    pub version: i32,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum SecretType {
    DatabaseCredential,
    ApiKey,
    SshKey,
    SslCertificate,
    JwtSecret,
    EncryptionKey,
}

pub struct RotationEngine {
    db_pool: PgPool,
    scheduler: JobScheduler,
    encryption_key: Arc<[u8; 32]>,
}

impl RotationEngine {
    pub async fn new(db_pool: PgPool, encryption_key: [u8; 32]) -> anyhow::Result<Self> {
        let scheduler = JobScheduler::new().await?;
        Ok(Self {
            db_pool,
            scheduler,
            encryption_key: Arc::new(encryption_key),
        })
    }

    pub async fn start(&self) -> anyhow::Result<()> {
        // Schedule rotation job every hour
        let job = Job::new("0 0 * * * *", |_uuid, _l| {
            Box::pin(async {
                if let Err(e) = Self::rotate_secrets().await {
                    error!("Secret rotation failed: {}", e);
                }
            })
        })?;

        self.scheduler.add(job).await?;
        self.scheduler.start().await?;

        info!("Secret rotation engine started");
        Ok(())
    }

    async fn rotate_secrets() -> anyhow::Result<()> {
        info!("Starting scheduled secret rotation");
        
        let now = Utc::now();
        let secrets_to_rotate = Self::get_secrets_due_for_rotation(now).await?;
        
        for secret in secrets_to_rotate {
            match secret.secret_type {
                SecretType::DatabaseCredential => {
                    Self::rotate_database_credential(&secret).await?;
                }
                SecretType::ApiKey => {
                    Self::rotate_api_key(&secret).await?;
                }
                SecretType::SslCertificate => {
                    Self::rotate_ssl_certificate(&secret).await?;
                }
                _ => {
                    Self::rotate_generic_secret(&secret).await?;
                }
            }
            
            // Update rotation timestamp
            Self::update_rotation_timestamp(&secret.id, now).await?;
            
            // Notify dependent services
            Self::notify_services(&secret.key, secret.version + 1).await?;
            
            info!("Rotated secret: {}", secret.key);
        }
        
        info!("Completed secret rotation for {} secrets", secrets_to_rotate.len());
        Ok(())
    }

    async fn rotate_database_credential(secret: &SecretMetadata) -> anyhow::Result<()> {
        let new_password = Self::generate_secure_password(32);
        
        // Update database password
        let db_url = secret.metadata.get("database_url").unwrap();
        let username = secret.metadata.get("username").unwrap();
        
        // Execute password change in the target database
        Self::execute_database_password_change(db_url, username, &new_password).await?;
        
        // Store encrypted new password
        let encrypted = Self::encrypt_secret(&new_password, &secret.id)?;
        Self::store_rotated_secret(&secret.key, &encrypted, secret.version + 1).await?;
        
        Ok(())
    }

    async fn rotate_api_key(secret: &SecretMetadata) -> anyhow::Result<()> {
        let new_api_key = Self::generate_api_key();
        let encrypted = Self::encrypt_secret(&new_api_key, &secret.id)?;
        
        Self::store_rotated_secret(&secret.key, &encrypted, secret.version + 1).await?;
        
        // Revoke old API key if configured
        if secret.metadata.get("revoke_old").unwrap_or(&"true".to_string()) == "true" {
            Self::revoke_old_api_key(&secret.key, secret.version).await?;
        }
        
        Ok(())
    }

    async fn rotate_ssl_certificate(secret: &SecretMetadata) -> anyhow::Result<()> {
        let domain = secret.metadata.get("domain").unwrap();
        let days_valid = secret.metadata.get("days_valid")
            .unwrap_or(&"90".to_string())
            .parse::<i32>()?;
        
        // Generate new certificate (in production, integrate with Let's Encrypt or your CA)
        let (cert, key) = Self::generate_self_signed_cert(domain, days_valid)?;
        
        let encrypted_cert = Self::encrypt_secret(&cert, &secret.id)?;
        let encrypted_key = Self::encrypt_secret(&key, &secret.id)?;
        
        Self::store_rotated_certificate(
            &secret.key, 
            &encrypted_cert, 
            &encrypted_key, 
            secret.version + 1
        ).await?;
        
        Ok(())
    }

    fn encrypt_secret(secret: &str, context: &str) -> anyhow::Result<String> {
        use aes_gcm::{
            aead::{Aead, KeyInit, OsRng},
            Aes256Gcm, Nonce
        };
        
        let key = aes_gcm::Key::<Aes256Gcm>::from_slice(&self.encryption_key);
        let cipher = Aes256Gcm::new(key);
        let nonce = Nonce::from_slice(&context.as_bytes()[..12]);
        
        let ciphertext = cipher.encrypt(nonce, secret.as_bytes())
            .map_err(|e| anyhow::anyhow!("Encryption failed: {}", e))?;
        
        Ok(base64::encode(ciphertext))
    }

    fn generate_secure_password(length: usize) -> String {
        use rand::Rng;
        const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                                abcdefghijklmnopqrstuvwxyz\
                                0123456789\
                                !@#$%^&*()_+-=[]{}|;:,.<>?";
        
        let mut rng = rand::thread_rng();
        (0..length)
            .map(|_| {
                let idx = rng.gen_range(0..CHARSET.len());
                CHARSET[idx] as char
            })
            .collect()
    }

    fn generate_api_key() -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_nanos().to_string());
        format!("sk_{:x}", hasher.finalize())
    }
}
```
