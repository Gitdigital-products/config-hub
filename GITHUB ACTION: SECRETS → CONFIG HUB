GITHUB ACTION: SECRETS → CONFIG HUB

What this does (plain English)

Reads GitHub repo secrets

Pushes them into Config Hub

Marks them as encrypted

Triggers live reload across services

No .env, no manual copying, no drift


This is chef’s kiss infra.


---

PART 1 — ACTION DESIGN (simple, powerful)

Action name:

config-hub-sync

Inputs

CONFIG_HUB_URL

CONFIG_HUB_API_KEY

TENANT_ID

SERVICE_NAME

ENV


Behavior

Reads process.env

Filters secrets by prefix (e.g. CFG_)

Pushes them to Config Hub

Auto-increments version



---

PART 2 — ACTION IMPLEMENTATION (Node)

Repo:

config-hub-github-action

action.yml

name: "Config Hub Sync"
description: "Sync GitHub secrets to Config Hub"

inputs:
  config_hub_url:
    required: true
  api_key:
    required: true
  tenant_id:
    required: true
  service:
    required: true
  env:
    required: true

runs:
  using: "node20"
  main: "index.js"


---

index.js

import fetch from "node-fetch";

const {
  INPUT_CONFIG_HUB_URL,
  INPUT_API_KEY,
  INPUT_TENANT_ID,
  INPUT_SERVICE,
  INPUT_ENV,
} = process.env;

for (const [key, value] of Object.entries(process.env)) {
  if (!key.startsWith("CFG_")) continue;

  const payload = {
    tenant_id: INPUT_TENANT_ID,
    service: INPUT_SERVICE,
    env: INPUT_ENV,
    key: key.replace("CFG_", ""),
    value,
    encrypted: true,
    version: Date.now(), // cheap monotonic version
  };

  await fetch(`${INPUT_CONFIG_HUB_URL}/configs`, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${INPUT_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  });
}

That’s it. No SDK needed. Dead simple. Ultra reliable.


---

PART 3 — HOW USERS CONSUME THIS (magic moment)

In any GitHub repo

name: Sync Configs

on:
  push:
    branches: [main]

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: gitdigital-products/config-hub-sync@v1
        with:
          config_hub_url: https://config.gitdigital.io
          api_key: ${{ secrets.CONFIG_HUB_API_KEY }}
          tenant_id: gitdigital
          service: ai-docs-writer
          env: prod

And in GitHub Secrets:

CFG_DATABASE_URL
CFG_STRIPE_KEY
CFG_OPENAI_KEY

Push →
Secrets sync →
Config Hub updates →
Live reload fires →
No deploy needed.

That’s a holy developer experience.


---

PART 4 — WHY THIS IS A KILLER FEATURE

Most tools:

manage secrets

manage configs

manage deploys


You just removed the boundaries between them.

This gives you:

GitHub-native onboarding

Zero learning curve

Sticky adoption

Viral spread across repos


Someone adds this once and then asks: “Why don’t all our repos do this?”

That’s product-market gravity.


---

PART 5 — OPTIONAL BUT DEVIOUS UPGRADES

Easy next multipliers:

dry-run: true

secret diff preview

rollback button

per-plan secret limits

audit log entries per sync


All bolt-ons. Core stays simple.




